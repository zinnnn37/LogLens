input {
  kafka {
    bootstrap_servers => "kafka:19092"
    topics => ["application-logs"]
    codec => json
    group_id => "logstash-consumer"
    auto_offset_reset => "earliest"
    consumer_threads => 3
    decorate_events => true
  }
}

filter {
  # ===================================
  # Kafka 메타데이터 정리
  # ===================================
  mutate {
    remove_field => ["@version", "event", "host"]
  }

  # ===================================
  # timestamp 필드 생성 (ISO 8601 형식)
  # ===================================
  # Fluent Bit에서 온 @timestamp를 ISO 8601 문자열로 timestamp 필드에 저장
  ruby {
    code => '
      ts = event.get("@timestamp")
      if ts
        event.set("timestamp", ts.to_iso8601)
      else
        now = Time.now
        event.set("@timestamp", now)
        event.set("timestamp", now.utc.iso8601)
      end
    '
  }

  # 완전 고유한 document_id 생성 (timestamp + trace_id + logger)
  ruby {
    code => '
      require "securerandom"
      require "digest"
      unique_str = "#{Time.now.utc.iso8601(6)}_#{SecureRandom.uuid}_#{event.get("trace_id")}_#{event.get("logger")}"
      event.set("[@metadata][doc_id]", Digest::SHA256.hexdigest(unique_str))
    '
  }

  # ===================================
  # log_id는 별도 생성 (검색용) - 완전히 고유하도록 UUID 추가
  # ===================================
  ruby {
    code => '
      require "securerandom"
      # 고유성을 보장하기 위해 UUID 추가
      unique_id = SecureRandom.uuid
      fingerprint_input = "#{event.get("@timestamp")}_#{event.get("trace_id")}_#{event.get("logger")}_#{event.get("message")}_#{unique_id}"
      event.set("[@metadata][temp_id]", Digest::SHA256.hexdigest(fingerprint_input))
    '
  }

  ruby {
    code => '
      temp_id = event.get("[@metadata][temp_id]")
      if temp_id
        log_id = temp_id[0..7].to_i(16)  # 8자리 (Long 범위 내 안전)
        event.set("log_id", log_id)
      end
    '
  }

  # ===================================
  # project_uuid 처리 (필수, 기본값 설정)
  # ===================================
  if ![project_uuid] or [project_uuid] == "" {
    mutate {
      add_field => { "project_uuid" => "default-project" }
    }
  }

  # ===================================
  # service_name 처리 (필수, 기본값 설정)
  # ===================================
  if ![service_name] or [service_name] == "" {
    mutate {
      add_field => { "service_name" => "unknown-service" }
    }
  }

  # ===================================
  # log_level & level 정규화 (필수: INFO, WARN, ERROR)
  # ===================================
  if [log_level] {
    mutate {
      uppercase => ["log_level"]
    }
    if [log_level] not in ["ERROR", "WARN", "INFO"] {
      mutate {
        replace => { "log_level" => "INFO" }
      }
    }
  } else {
    mutate {
      add_field => { "log_level" => "INFO" }
    }
  }

  # level 필드 동기화 (AI 코드 호환성)
  mutate {
    copy => { "log_level" => "level" }
  }

  # ===================================
  # source_type 정규화 (FE, BE, INFRA)
  # ===================================
  if ![source_type] or [source_type] not in ["FE", "BE", "INFRA"] {
    mutate {
      replace => { "source_type" => "BE" }
    }
  }

  # ===================================
  # layer 정규화 (Controller, Service, Repository, Filter, Util, Other)
  # ===================================
  if [layer] and [layer] not in ["Controller", "Service", "Repository", "Filter", "Util", "Other"] {
    mutate {
      remove_field => ["layer"]
    }
  }

  # ===================================
  # trace_id 기본값 설정
  # ===================================
  if ![trace_id] or [trace_id] == "" {
    mutate {
      add_field => { "trace_id" => "unknown" }
    }
  }

  # ===================================
  # 필드 타입 변환
  # ===================================
  if [duration] {
    mutate {
      convert => { "duration" => "integer" }
    }
  }

  if [log_details][execution_time] {
    mutate {
      convert => { "[log_details][execution_time]" => "integer" }
    }
  }

  if [log_details][response_status] {
    mutate {
      convert => { "[log_details][response_status]" => "integer" }
    }
  }

  # ===================================
  # indexed_at 타임스탬프 추가
  # ===================================
  ruby {
    code => 'event.set("indexed_at", Time.now.utc.strftime("%Y-%m-%dT%H:%M:%S.%LZ"))'
  }

  # ===================================
  # response_body를 항상 문자열로 변환 (mapping conflict 방지)
  # ===================================
  if [log_details][response_body] {
    ruby {
      code => '
        response_body = event.get("[log_details][response_body]")
        if response_body
          if response_body.is_a?(Hash) || response_body.is_a?(Array)
            event.set("[log_details][response_body]", response_body.to_json)
          else
            event.set("[log_details][response_body]", response_body.to_s)
          end
        end
      '
    }
  }

  # ===================================
  # 불필요한 필드 제거
  # ===================================
  mutate {
    remove_field => [
      "log",
      "@version",
      "package",
      "app_name",
      "pid",
      "thread",
      "hostname",
      "file"
    ]
  }
}

output {
  # ===================================
  # OpenSearch 출력
  # ===================================
  opensearch {
    hosts => ["http://opensearch:9200"]
    index => "logs-%{+YYYY.MM}"

    # Document ID 설정 (중복 방지)
    document_id => "%{[@metadata][doc_id]}"
    action => "create"

    # 실패 시 재시도
    retry_on_conflict => 3

    # 보안 설정이 비활성화되어 있으므로 인증 불필요
    # user => "admin"
    # password => "Admin123!@#"
    # ssl => false
  }

  # ===================================
  # 디버깅용 출력 (필요시 활성화)
  # ===================================
  stdout {
    codec => rubydebug {
      metadata => true
    }
  }
}
