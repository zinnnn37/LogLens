input {
  kafka {
    bootstrap_servers => "kafka:19092"
    topics => ["application-logs"]
    codec => json
    group_id => "logstash-consumer"
    auto_offset_reset => "earliest"
    consumer_threads => 3
    decorate_events => true
  }
}

filter {
  # ===================================
  # Kafka 메타데이터 정리
  # ===================================
  mutate {
    remove_field => ["@version", "event", "host"]
  }

  # ===================================
  # timestamp 필드 생성 (ISO 8601 형식)
  # ===================================
  ruby {
    code => '
      ts = event.get("@timestamp")
      if ts
        event.set("timestamp", ts.to_iso8601)
      else
        now = Time.now
        event.set("@timestamp", now)
        event.set("timestamp", now.utc.iso8601)
      end
    '
  }

  # ===================================
  # 완전 고유한 document_id 생성
  # ===================================
  ruby {
    code => '
      require "securerandom"
      require "digest"
      unique_str = "#{Time.now.utc.iso8601(6)}_#{SecureRandom.uuid}_#{event.get("trace_id")}_#{event.get("logger")}"
      event.set("[@metadata][doc_id]", Digest::SHA256.hexdigest(unique_str))
    '
  }

  # ===================================
  # log_id 생성 (검색용)
  # ===================================
  ruby {
    code => '
      require "securerandom"
      require "digest"
      unique_id = SecureRandom.uuid
      fingerprint_input = "#{event.get("@timestamp")}_#{event.get("trace_id")}_#{event.get("logger")}_#{event.get("message")}_#{unique_id}"
      event.set("[@metadata][temp_id]", Digest::SHA256.hexdigest(fingerprint_input))
    '
  }

  ruby {
    code => '
      temp_id = event.get("[@metadata][temp_id]")
      if temp_id
        log_id = temp_id[0..7].to_i(16)
        event.set("log_id", log_id)
      end
    '
  }

  # ===================================
  # ⭐ log_details 파싱 (Java Map toString 형태)
  # ===================================
  if [log_details] {
    ruby {
      code => '
        log_details = event.get("log_details")

        # 문자열인 경우 파싱 시도
        if log_details.is_a?(String)
          # 1. 먼저 표준 JSON 파싱 시도
          require "json"
          begin
            parsed = JSON.parse(log_details)
            event.set("log_details", parsed)
          rescue => json_error
            # 2. JSON 파싱 실패 시 Java Map toString() 형태로 간주하고 정규식으로 추출
            begin
              # 새로운 log_details Hash 생성
              parsed_details = {}

              # http_method 추출 (http_method=VALUE 패턴)
              if log_details =~ /http_method=(\w+)/
                parsed_details["http_method"] = $1
              end

              # request_uri 추출 (request_uri=VALUE 패턴, 다음 쉼표 또는 닫는 괄호까지)
              if log_details =~ /request_uri=([^,}]+)/
                parsed_details["request_uri"] = $1.strip
              end

              # execution_time 추출 (execution_time=숫자 패턴)
              if log_details =~ /execution_time=(\d+)/
                parsed_details["execution_time"] = $1.to_i
              end

              # response_status 추출
              if log_details =~ /response_status=(\d+)/
                parsed_details["response_status"] = $1.to_i
              end

              # class_name 추출 (패키지명 포함)
              if log_details =~ /class_name=([a-zA-Z0-9._]+)/
                parsed_details["class_name"] = $1
              end

              # method_name 추출
              if log_details =~ /method_name=(\w+)/
                parsed_details["method_name"] = $1
              end

              # 추출된 필드가 있으면 log_details를 Hash로 교체
              if parsed_details.any?
                event.set("log_details", parsed_details)
                event.set("[@metadata][log_details_parse_method]", "regex")
              else
                # 추출 실패 시 원본 유지 및 에러 로깅
                event.set("[@metadata][log_details_parse_error]", "No fields extracted from Java Map toString")
              end
            rescue => regex_error
              # 정규식 파싱도 실패 시 에러 로깅
              event.set("[@metadata][log_details_parse_error]", "Regex parsing failed: #{regex_error.message}")
            end
          end
        elsif log_details.is_a?(Hash)
          # 이미 Hash면 그대로 사용 (정상 케이스)
          event.set("[@metadata][log_details_parse_method]", "already_hash")
        end
      '
    }
  }

  # ===================================
  # log_details 필드 타입 명시적 변환
  # ===================================
  if [log_details][execution_time] {
    mutate {
      convert => { "[log_details][execution_time]" => "integer" }
    }
  }

  if [log_details][response_status] {
    mutate {
      convert => { "[log_details][response_status]" => "integer" }
    }
  }

  # http_method와 request_uri가 없으면 상위 레벨에서 복사 시도
  if [log_details] and ![log_details][http_method] and [http_method] {
    mutate {
      add_field => { "[log_details][http_method]" => "%{http_method}" }
    }
  }

  if [log_details] and ![log_details][request_uri] and [request_uri] {
    mutate {
      add_field => { "[log_details][request_uri]" => "%{request_uri}" }
    }
  }

  # ===================================
  # project_uuid 처리 및 안전한 인덱스용 필드 생성
  # ===================================
  if ![project_uuid] or [project_uuid] == "" {
    mutate {
      add_field => { "project_uuid" => "default_project" }
    }
  }

  ruby {
    code => '
      if event.get("project_uuid")
        safe_uuid = event.get("project_uuid").gsub("-", "_")
        event.set("safe_project_uuid", safe_uuid)
      else
        event.set("safe_project_uuid", "default_project")
      end
    '
  }

  # ===================================
  # service_name 기본값
  # ===================================
  if ![service_name] or [service_name] == "" {
    mutate {
      add_field => { "service_name" => "unknown_service" }
    }
  }

  # ===================================
  # log_level & level 정규화
  # ===================================
  if [log_level] {
    mutate { uppercase => ["log_level"] }
    if [log_level] not in ["ERROR", "WARN", "INFO"] {
      mutate { replace => { "log_level" => "INFO" } }
    }
  } else {
    mutate { add_field => { "log_level" => "INFO" } }
  }

  mutate { copy => { "log_level" => "level" } }

  # ===================================
  # source_type 정규화
  # ===================================
  if ![source_type] or [source_type] not in ["FE", "BE", "INFRA"] {
    mutate { replace => { "source_type" => "BE" } }
  }

  # ===================================
  # layer 정규화
  # ===================================
  if [layer] and [layer] not in ["Controller", "Service", "Repository", "Filter", "Util", "Other"] {
    mutate { remove_field => ["layer"] }
  }

  # ===================================
  # trace_id 통합 및 기본값
  # ===================================
  if ![trace_id] and [traceId] {
    mutate { copy => { "traceId" => "trace_id" } }
  }
  if ![trace_id] or [trace_id] == "" {
    mutate { add_field => { "trace_id" => "unknown" } }
  }

  # ===================================
  # 타입 변환
  # ===================================
  if [duration] {
    mutate { convert => { "duration" => "integer" } }
  }

  # ===================================
  # indexed_at 추가
  # ===================================
  ruby {
    code => 'event.set("indexed_at", Time.now.utc.strftime("%Y-%m-%dT%H:%M:%S.%LZ"))'
  }

  # ===================================
  # 불필요한 필드 제거
  # ===================================
  mutate {
    remove_field => [
      "log",
      "@version",
      "package",
      "app_name",
      "pid",
      "thread",
      "hostname",
      "file"
    ]
  }
}

output {
  # ===================================
  # OpenSearch 출력 (project_uuid + YYYY_MM)
  # ===================================
  opensearch {
    hosts => ["http://opensearch:9200"]
    index => "%{safe_project_uuid}_%{+YYYY_MM}"
    document_id => "%{[@metadata][doc_id]}"
    action => "create"
    retry_on_conflict => 3
  }

  # ===================================
  # 디버깅용 출력 (조건부 - 개발 환경에서만 활성화)
  # ===================================
  # 파싱 에러가 있을 때만 출력
  if [@metadata][log_details_parse_error] {
    stdout {
      codec => line {
        format => "⚠️  log_details parsing failed: %{[@metadata][log_details_parse_error]} | log_id: %{log_id}"
      }
    }
  }

  # 파싱 성공 시 메소드 표시 (선택적, 디버깅용)
  # if [@metadata][log_details_parse_method] == "regex" {
  #   stdout {
  #     codec => line {
  #       format => "✅ log_details parsed via regex | http_method: %{[log_details][http_method]} | request_uri: %{[log_details][request_uri]}"
  #     }
  #   }
  # }
}
